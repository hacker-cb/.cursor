---
alwaysApply: true
---
# Rules Management

Guidelines for managing project-specific cursor rules.

## Rule Precedence

**Local rules always override shared rules.**

- Local rules take priority when both address same topic
- Shared rules provide defaults when no local rule exists
- No merging - local rule completely replaces shared rule
- Allows project-specific customizations and experimentation

## Modifying Shared Rules

**Never modify `shared-*.mdc` files directly in projects.**

- Modifications will be overwritten on next sync
- Creates inconsistency across projects
- Causes sync conflicts

**Instead:**
- Create `local-*.mdc` files to override shared rules
- Update shared rules in central `.cursor/` repository
- Re-sync to distribute improvements across projects

## Naming Patterns

Use `local-` prefix for project-specific rules.

**Choose pattern based on project architecture:**

**Multi-platform projects** (embedded, cross-platform):
- Pattern: `local-platform-{name}-{aspect}.mdc`
- Platform is primary architectural concern
- Example: `local-platform-esp32-testing.mdc`

**Multi-module projects** (web services, apps):
- Pattern: `local-{aspect}-{module}.mdc`
- Cross-cutting concerns span modules
- Example: `local-testing-backend.mdc`

**Cross-cutting rules** (any project):
- Pattern: `local-{topic}.mdc`
- Applies across entire project
- Example: `local-architecture.mdc`

## When to Create Project Rules

Create project-specific rules when:
- Tech stack is chosen and patterns emerge
- Framework or language-specific conventions need documentation
- Platform-specific practices develop
- Project architecture decisions are made
- Architecture evolves (refactoring, new modules, migration)
- Adding rules to existing project (use `init-cursor-rules` command)

Project rules can be language/framework-specific (unlike shared rules which are universal).

## Project-Specific Topics

Common topics that require local rules:
- API design patterns for your tech stack
- Deployment strategies for your infrastructure
- Hardware abstraction (embedded projects)
- Platform-specific guidelines (mobile, embedded)
- Observability and monitoring setup
- Database schema and conventions
- Module or service boundaries

Create only what your project needs.

## File Length Guidelines

- **Target**: 50-150 lines for most files
- **Maximum**: 300 lines when comprehensive coverage needed
- **Priority**: Completeness of single aspect over arbitrary limits
- **One aspect per file** - don't mix testing with security, code quality with deployment
- **Keep together** - don't artificially split coherent topics
- **Write efficiently** - bullet points, remove verbosity, stay actionable

## Targeting Rules to Files

Use YAML frontmatter to control which files each rule applies to.

**Add tags for categorization:**
- Helps organize rules by language, framework, or concern
- Examples: `["python", "backend"]`, `["typescript", "frontend"]`

**Add globs to target specific files:**
- Match by file type: `["**/*.c", "**/*.h"]`
- Match by directory: `["backend/**/*"]`
- Multiple patterns: `["api/**/*.py", "services/**/*.py"]`
- Exclude patterns: `["src/**/*.ts", "!**/*.test.ts"]`

Test your globs against actual project files to verify they match intended targets.

## Maintenance

Keep project rules up to date:
- Update when tech stack evolves
- Review when adding modules/platforms
- Remove when components are deprecated
- Review quarterly for relevance

## .cursor/ Folder Scope

**One `.cursor/` folder per git repository.**

✅ **Valid**: Each git repository has its own `.cursor/`
- Main repository: `.cursor/`
- Git submodule A: `submodules/lib-a/.cursor/`
- Git submodule B: `submodules/lib-b/.cursor/`

❌ **Invalid**: Multiple `.cursor/` folders in same repository
- Causes unclear IDE behavior
- Creates unpredictable precedence
- Increases maintenance complexity

**Instead of nested folders, use:**
- Glob patterns to target subdirectories
- Module-specific rule files (`local-backend.mdc`, `local-frontend.mdc`)
- Tags to organize rules within single `.cursor/rules/`

**If you find nested `.cursor/` folders:**
1. Check if subdirectory is git submodule (valid if yes)
2. If same repo, consolidate into root `.cursor/` with globs/tags
3. Sync each git repository's `.cursor/` independently
