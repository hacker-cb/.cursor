---
alwaysApply: true
---
# Version Control

Git workflow and collaboration standards.

## Commit Message Standards

Use conventional commits for clarity and consistency.

**Format:** `type(scope): description`

**Types:**
- `feat` - New feature
- `fix` - Bug fix
- `docs` - Documentation
- `style` - Formatting
- `refactor` - Code refactoring
- `test` - Tests
- `perf` - Performance
- `build` - Build system changes
- `ci` - CI/CD configuration
- `chore` - Maintenance

**Best practices:**
- Clear and concise description
- Use present tense
- Describe what and why
- Reference issue numbers when applicable
- Add body for complex changes

**Examples:**
- `feat(auth): add OAuth login`
- `fix(api): handle null database response`
- `refactor(parser): simplify token handling`
- `ci(esp32): add parallel test matrix`
- `build(cmake): update compiler flags`

**Cursor rules and commands (`.cursor/`):**
- Scope: `cursor-rules` for rules, `cursor-cmd` for commands
- Use standard types (feat, fix, docs, refactor, build, ci, etc.)
- Examples:
  - `feat(cursor-rules): add testing standards`
  - `docs(cursor-rules): update commit message policy`
  - `feat(cursor-cmd): add security audit command`
  - `fix(cursor-cmd): update sync command`

**Multi-platform/module projects:**
- Scope: platform, module, aspect, or subsystem name
- Use `/` to specify subsystems
- Examples:
  - `feat(esp32): add WiFi driver`
  - `fix(stm32): resolve SPI timing`
  - `feat(backend): add user endpoint`
  - `fix(esp32/drivers): add I2C support`
  - `fix(backend/api): handle timeout`

## Branch Naming

Use consistent, descriptive branch names.

**Pattern:** `type/description`

**Examples:**
- `feature/user-authentication`
- `bugfix/login-error-handling`
- `hotfix/critical-memory-leak`
- `refactor/simplify-api-layer`

**Guidelines:**
- Lowercase with hyphens
- Descriptive but concise
- Include issue number when applicable
- Avoid ambiguous names

## Git Workflow

**Branch and commit:**
- Create feature branches from main branch (master, main, devel, or develop depending on project)
- Commit early and often
- Keep commits atomic (one logical change)
- Write meaningful commit messages
- Each commit should work (build and pass tests)

**Stay synchronized:**
- Pull latest changes before starting work
- Sync with main branch regularly
- Resolve conflicts promptly
- Push changes to remote regularly

**Keep history clean:**
- Keep related commits organized
- Don't commit WIP to main branches
- Use `.gitignore` properly
- Remove temporary/debug commits

**Never commit:**
- Secrets or credentials
- Generated files (unless necessary)
- Personal IDE configurations
- Large binary files (use Git LFS if needed)
- Sensitive data

**Merge conflicts:**
- Communicate with affected developers
- Understand both sides
- Test thoroughly after resolution
- Don't blindly pick one side
- Commit resolution separately

## Rebase vs Merge

**Rebase:**
- For feature branches before merging
- Creates linear history
- Easier to follow
- Never rebase public/shared branches

**Merge commit (--no-ff) - DEFAULT:**
- Default method for merging feature branches to main branches (master/main/devel/develop)
- Preserves complete branch history
- Creates explicit merge commit even for fast-forward merges
- Makes it clear when features were integrated
- Command: `git merge --no-ff feature-branch`

**Merge:**
- For long-lived branches
- Preserves complete history
- Safer for shared work

**Squash and merge:**
- Only use when explicitly requested by user
- Combines commits into one
- Keeps main branch history clean
- Trade-off: loses individual commit history

**Guidelines:**
- Before merging, ask user: "Do you want to: a) Merge commit (--no-ff) to preserve branch history, or b) Squash merge to combine commits into one?"
- Default to merge commit (--no-ff) if user doesn't specify
- Rebase feature on main branch before PR
- Keep related commits within branch
- Never force push to shared branches

## Pull Requests

**PR description:**
- Clear title
- What changed and why
- Link to related issues
- Breaking changes highlighted
- Testing instructions
- Screenshots for UI changes

**Before creating:**
- Self-review your changes
- All tests pass locally
- Documentation updated
- Code formatted and linted
- No debug code or TODOs
- No sensitive information

**PR size:**
- Focused and reasonably sized
- Split large changes
- One logical change per PR

**Draft PRs:**
- Early feedback on approach
- Mark ready when complete

**Responding to feedback:**
- Address all comments
- Don't force push during review
- Discuss and resolve conversations
- Re-request review after changes

**PR lifecycle:**
- Keep updated with master
- Monitor CI/CD status
- Be responsive
- Don't let PRs go stale

## Code Review

**What to review:**
- Functionality correctness
- Code quality and readability
- Test coverage adequacy
- Security and performance
- Backward compatibility

**Giving feedback:**
- Be constructive and specific
- Explain reasoning
- Suggest alternatives
- Appreciate good work
- Focus on code, not person

**Comment types:**
- `nit:` - Minor, not blocking
- `blocking:` - Must fix
- `question:` - Need clarification
- `suggestion:` - Optional
- `praise:` - Acknowledge good work

**Receiving feedback:**
- Don't take personally
- Fix blocking issues promptly
- Discuss concerns respectfully
- Implement or respond to all

**Review timing:**
- Within 1-2 business days
- Prioritize urgent changes
- Balance thoroughness with speed

## Merge Requirements

**Before merging:**
- All tests pass
- Code review approved
- No merge conflicts
- CI/CD checks green
- Documentation updated
- Linter passes
- Branch up to date with main branch

**Merge strategy:**
- Ask user: "Do you want to: a) Merge commit (--no-ff) to preserve branch history, or b) Squash merge to combine commits into one?"
- Default to merge commit (--no-ff) if user doesn't specify
- Use `git merge --no-ff <branch>` for merge commits
- Use `git merge --squash <branch>` for squash merges

**After merge:**
- Delete feature branch
- Close related issues
- Monitor deployment
- Verify change works

## Branch Management

**Creating branches:**
- Branch from main branch (master, main, devel, or develop depending on project)
- Descriptive names
- Focused purpose
- Push early

**Protected branch policy:**
- No direct commits to main branches (master/main)
- No direct commits to development branches (devel/develop)
- Always require feature branches for changes
- Always require PR for merging to protected branches

**When user attempts work on protected branches:**
1. Detect if current branch is master, main, dev, or develop
2. Suggest creating appropriate feature branch based on change context
3. Propose branch name following naming conventions
4. Ask user for confirmation before creating branch
5. Only create branch after user approval
6. Never commit directly without explicit user override

**Maintaining branches:**
- Sync with main branch regularly
- Keep CI green
- Update with feedback

**Cleanup:**
- Delete after merge
- Remove stale branches regularly
- Archive important unmerged work

## CI/CD Workflows

**GitHub Actions workflows:**
- Always include `workflow_dispatch` trigger in all workflows
- Enables manual workflow execution
- Required for autofix and debugging capabilities
- Add alongside other triggers (push, pull_request, etc.)

**Example workflow trigger configuration:**
```yaml
on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]
  workflow_dispatch:  # Always include this
```

**Workflow best practices:**
- Pin action versions (use commit SHA or tags)
- Add timeout limits to prevent runaway jobs
- Use secrets for credentials
- Cache dependencies when possible
- Fail fast on errors
- Keep workflows focused and modular

**Workflow testing:**
- Test workflows in feature branches
- Use workflow_dispatch for manual testing
- Verify all paths and conditions
- Test failure scenarios

## Collaboration

**Team communication:**
- Keep team informed
- Discuss architectural changes early
- Ask for help when stuck
- Share knowledge
- Communicate breaking changes

**Protect main branches:**
- Enforce branch protection rules (see Branch Management section)
- Require status checks
- Require reviews
- Prevent force push to main branches

**Note:** Use "master" for new projects, or follow existing project convention (main/devel/develop).
