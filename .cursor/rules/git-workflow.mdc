---
alwaysApply: true
---
# Git Workflow

Universal git workflow and branching strategy for project development.

## Branch Types and Names

**Main branches (preferred names in order):**
- `master` (most preferred)
- `main`

**Development branches (preferred names in order):**
- `dev` (most preferred)
- `develop`

**Protected branches:**
- Never commit directly to main or development branches
- Always create feature branches for changes
- If user attempts to commit to protected branches, suggest creating appropriate feature branch and ask for confirmation before creating

## Feature Branch Naming Conventions

Use descriptive branch names that reflect the type of change.

**Pattern:** `type/description` or `type-description`

**Common types:**
- `feature/*` or `feat/*` - New features or functionality
- `fix/*` or `bugfix/*` - Bug fixes
- `hotfix/*` - Critical production fixes
- `refactor/*` - Code restructuring without behavior change
- `docs/*` - Documentation changes
- `test/*` - Test additions or modifications
- `chore/*` - Maintenance tasks

**Examples:**
- `feature/user-authentication`
- `fix/login-validation-error`
- `hotfix/security-patch`
- `refactor/database-layer`
- `docs/api-documentation`

## Commit Message Format

Follow conventional commits standard.

**Format:** `type(scope): description`

**Types:**
- `feat` - New feature
- `fix` - Bug fix
- `docs` - Documentation changes
- `style` - Code style changes (formatting, semicolons, etc.)
- `refactor` - Code refactoring
- `test` - Test additions or modifications
- `chore` - Maintenance tasks
- `perf` - Performance improvements
- `ci` - CI/CD changes
- `build` - Build system changes

**Scope (optional):**
- Module, component, or area affected
- Examples: `auth`, `api`, `ui`, `database`, `config`

**Examples:**
- `feat(auth): add OAuth2 login support`
- `fix(api): resolve null pointer in user endpoint`
- `docs: update installation instructions`
- `refactor(database): optimize query performance`
- `test(api): add integration tests for user service`

## Commit Practices

**Atomic commits:**
- One logical change per commit
- Each commit should be independently deployable
- Related changes stay together

**Commit quality:**
- Write clear, descriptive messages
- Explain what and why, not how
- Reference issue numbers when applicable
- Keep commits focused and small

**What to commit:**
- Source code changes
- Configuration files
- Documentation updates
- Test files
- Build scripts

**Never commit:**
- Secrets, credentials, API keys
- Generated files (build artifacts, compiled code)
- IDE-specific settings (unless shared)
- Dependencies (node_modules, vendor, etc.)
- Temporary files
- Large binary files without LFS

## Workflow Process

**Starting work:**
1. Sync with main branch
2. Create descriptive feature branch
3. Make focused changes
4. Write tests for changes
5. Commit with clear messages

**Before creating PR:**
- Self-review all changes
- Run tests locally
- Update documentation if needed
- Ensure commit messages follow format
- Rebase on main branch if needed
- No WIP or debug commits

**Pull request:**
- Clear, descriptive title
- Explain what, why, and how
- Link related issues
- Add screenshots for UI changes
- Request appropriate reviewers
- Mark as draft for early feedback

## Branch Management

**Feature branches:**
- Branch from main branch (master or main)
- One feature/fix per branch
- Keep branches focused and short-lived
- Sync with main branch regularly
- Delete after merge

**Branch protection policy:**
- No direct commits to main branches (master/main)
- No direct commits to development branches (dev/develop)
- Always require feature branches for changes
- Always require PR for merging to protected branches

**When user attempts work on protected branches:**
1. Detect if current branch is main or development branch
2. Suggest creating appropriate feature branch based on change context
3. Propose branch name following naming conventions
4. Ask user for confirmation before creating branch
5. Only create branch after user approval

**After merge:**
- Delete feature branch
- Pull latest from main branch
- Start new branch for next change

## Merge Strategy

**Before merging:**
- All reviews approved
- All tests passing
- No conflicts with main branch
- Commit messages follow format
- Documentation updated

**Merge methods:**
- **Squash and merge** - For feature branches (cleaner history)
- **Rebase and merge** - For linear history preference
- **Merge commit** - For preserving full branch history
- Choose based on team preference and project needs

**After merge:**
- Delete merged branch
- Monitor for issues

## Release Management

**Versioning:**
- Follow semantic versioning (SemVer): `MAJOR.MINOR.PATCH`
- MAJOR: Breaking changes
- MINOR: New features (backward compatible)
- PATCH: Bug fixes (backward compatible)

**Release branches:**
- Create from main branch for release preparation
- Name: `release/v1.2.3`
- Only bug fixes allowed
- Merge back to main and dev

**Hotfix branches:**
- Create from main for critical production fixes
- Name: `hotfix/issue-description`
- Merge to main and dev
- Tag immediately

**Tags:**
- Tag all releases: `v1.2.3`
- Use annotated tags with changelog
- Push tags to remote
- Never delete or move tags

## Collaboration

**Communication:**
- Keep changes focused and understandable
- Discuss major changes before implementation
- Document decisions in commits and PRs
- Share knowledge with team

**Code review focus:**
- Code quality and standards
- Test coverage
- Security concerns
- Performance implications
- Documentation completeness

**Conflict resolution:**
- Communicate with team members
- Resolve conflicts promptly
- Test thoroughly after resolution
- Ask for help when needed
